package storage

import (
	"kkemi/api"
	"kkemi/models"
	"fmt"
	"os"
	"testing"
	"time"
)

type mockAPIClient struct {
	userInfo *api.UserInfo
	top100   *api.Top100Response
	err      error
}

func (m *mockAPIClient) GetUserInfo(handle string) (*api.UserInfo, error) {
	return m.userInfo, m.err
}

func (m *mockAPIClient) GetUserTop100(handle string) (*api.Top100Response, error) {
	return m.top100, m.err
}

func (m *mockAPIClient) GetUserAdditionalInfo(handle string) (*api.UserAdditionalInfo, error) {
	return nil, nil
}

func (m *mockAPIClient) GetUserOrganizations(handle string) ([]api.Organization, error) {
	return []api.Organization{}, nil
}

func TestStorage_validateParticipantInput(t *testing.T) {
	storage := &Storage{}

	tests := []struct {
		name       string
		username   string
		baekjoonID string
		expectErr  bool
	}{
		{"Valid inputs", "홍길동", "testuser", false},
		{"Invalid username - empty", "", "testuser", true},
		{"Invalid username - too short", "a", "testuser", true},
		{"Invalid baekjoon ID - empty", "홍길동", "", true},
		{"Invalid baekjoon ID - too short", "홍길동", "ab", true},
		{"Invalid baekjoon ID - starts with number", "홍길동", "123test", true},
		{"Invalid username - contains special chars", "user@domain", "testuser", true},
		{"Invalid baekjoon ID - contains special chars", "홍길동", "test-user", true},
	}

	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			err := storage.validateParticipantInput(test.username, test.baekjoonID)
			if test.expectErr && err == nil {
				t.Errorf("Expected error but got nil")
			}
			if !test.expectErr && err != nil {
				t.Errorf("Expected no error but got: %v", err)
			}
		})
	}
}

func TestStorage_checkDuplicateParticipant(t *testing.T) {
	storage := &Storage{
		participants: []models.Participant{
			{Name: "기존사용자", BaekjoonID: "existing_user"},
			{Name: "다른사용자", BaekjoonID: "another_user"},
		},
	}

	tests := []struct {
		name       string
		username   string
		baekjoonID string
		expectErr  bool
	}{
		{"New unique participant", "새사용자", "new_user", false},
		{"Duplicate baekjoon ID", "새사용자", "existing_user", true},
		{"Duplicate name", "기존사용자", "new_user", true},
		{"Both duplicates", "기존사용자", "existing_user", true},
	}

	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			err := storage.checkDuplicateParticipant(test.username, test.baekjoonID)
			if test.expectErr && err == nil {
				t.Errorf("Expected error but got nil")
			}
			if !test.expectErr && err != nil {
				t.Errorf("Expected no error but got: %v", err)
			}
		})
	}
}

func TestStorage_fetchStartingProblems(t *testing.T) {
	mockTop100 := &api.Top100Response{
		Count: 3,
		Items: []api.ProblemInfo{
			{ProblemID: 1001},
			{ProblemID: 1002},
			{ProblemID: 1003},
		},
	}

	t.Run("Successful API call", func(t *testing.T) {
		mockClient := &mockAPIClient{top100: mockTop100}
		storage := &Storage{apiClient: mockClient}

		problemIDs, count := storage.fetchStartingProblems("testuser")

		if count != 3 {
			t.Errorf("Expected count 3, got %d", count)
		}
		if len(problemIDs) != 3 {
			t.Errorf("Expected 3 problem IDs, got %d", len(problemIDs))
		}
		expected := []int{1001, 1002, 1003}
		for i, id := range expected {
			if problemIDs[i] != id {
				t.Errorf("Expected problem ID %d at index %d, got %d", id, i, problemIDs[i])
			}
		}
	})

	t.Run("API error handling", func(t *testing.T) {
		mockClient := &mockAPIClient{err: fmt.Errorf("API error")}
		storage := &Storage{apiClient: mockClient}

		problemIDs, count := storage.fetchStartingProblems("testuser")

		if count != 0 {
			t.Errorf("Expected count 0 on API error, got %d", count)
		}
		if len(problemIDs) != 0 {
			t.Errorf("Expected 0 problem IDs on API error, got %d", len(problemIDs))
		}
	})
}

func TestStorage_createParticipant(t *testing.T) {
	storage := &Storage{
		participants: []models.Participant{
			{ID: 1},
			{ID: 2},
		},
	}

	participant := storage.createParticipant(
		"테스트 사용자",
		"testuser",
		11,
		1400,
		[]int{1001, 1002},
		2,
	)

	if participant.ID != 3 {
		t.Errorf("Expected ID 3, got %d", participant.ID)
	}
	if participant.Name != "테스트 사용자" {
		t.Errorf("Expected name '테스트 사용자', got '%s'", participant.Name)
	}
	if participant.BaekjoonID != "testuser" {
		t.Errorf("Expected baekjoon ID 'testuser', got '%s'", participant.BaekjoonID)
	}
	if participant.StartTier != 11 {
		t.Errorf("Expected start tier 11, got %d", participant.StartTier)
	}
	if participant.StartRating != 1400 {
		t.Errorf("Expected start rating 1400, got %d", participant.StartRating)
	}
	if len(participant.StartProblemIDs) != 2 {
		t.Errorf("Expected 2 start problem IDs, got %d", len(participant.StartProblemIDs))
	}
	if participant.StartProblemCount != 2 {
		t.Errorf("Expected start problem count 2, got %d", participant.StartProblemCount)
	}
}

func TestStorage_RemoveParticipant(t *testing.T) {
	// 테스트용 임시 파일 준비
	tempFile := "test_participants.json"
	defer os.Remove(tempFile)

	storage := &Storage{
		participants: []models.Participant{
			{ID: 1, Name: "사용자1", BaekjoonID: "user1"},
			{ID: 2, Name: "사용자2", BaekjoonID: "user2"},
			{ID: 3, Name: "사용자3", BaekjoonID: "user3"},
		},
	}

	t.Run("Remove existing participant", func(t *testing.T) {
		initialCount := len(storage.participants)
		err := storage.RemoveParticipant("user2")
		
		if err != nil {
			t.Errorf("Expected no error, got: %v", err)
		}
		if len(storage.participants) != initialCount-1 {
			t.Errorf("Expected %d participants, got %d", initialCount-1, len(storage.participants))
		}
		
		// 제거된 참가자가 실제로 제거되었는지 확인
		for _, p := range storage.participants {
			if p.BaekjoonID == "user2" {
				t.Error("Participant user2 should have been removed")
			}
		}
	})

	t.Run("Remove non-existent participant", func(t *testing.T) {
		err := storage.RemoveParticipant("nonexistent")
		
		if err == nil {
			t.Error("Expected error for non-existent participant")
		}
	})
}

func TestStorage_CreateCompetition(t *testing.T) {
	storage := &Storage{
		participants: []models.Participant{
			{ID: 1, Name: "사용자1"},
			{ID: 2, Name: "사용자2"},
		},
	}

	startDate := time.Date(2024, 1, 1, 0, 0, 0, 0, time.UTC)
	endDate := time.Date(2024, 1, 31, 23, 59, 59, 0, time.UTC)

	err := storage.CreateCompetition("테스트 대회", startDate, endDate)
	if err != nil {
		t.Errorf("Expected no error, got: %v", err)
	}

	competition := storage.GetCompetition()
	if competition == nil {
		t.Fatal("Competition should not be nil")
	}

	if competition.Name != "테스트 대회" {
		t.Errorf("Expected name '테스트 대회', got '%s'", competition.Name)
	}
	if !competition.StartDate.Equal(startDate) {
		t.Errorf("Expected start date %v, got %v", startDate, competition.StartDate)
	}
	if !competition.EndDate.Equal(endDate) {
		t.Errorf("Expected end date %v, got %v", endDate, competition.EndDate)
	}
	if !competition.IsActive {
		t.Error("Competition should be active")
	}
	if !competition.ShowScoreboard {
		t.Error("Scoreboard should be visible")
	}
	if len(competition.Participants) != 2 {
		t.Errorf("Expected 2 participants, got %d", len(competition.Participants))
	}

	// 블랙아웃 기간 검증 (종료일 3일 전)
	expectedBlackout := endDate.AddDate(0, 0, -3)
	if !competition.BlackoutStartDate.Equal(expectedBlackout) {
		t.Errorf("Expected blackout start %v, got %v", expectedBlackout, competition.BlackoutStartDate)
	}
}

func TestStorage_SetScoreboardVisibility(t *testing.T) {
	storage := &Storage{}

	t.Run("No active competition", func(t *testing.T) {
		err := storage.SetScoreboardVisibility(false)
		if err == nil {
			t.Error("Expected error when no active competition")
		}
	})

	t.Run("With active competition", func(t *testing.T) {
		storage.competition = &models.Competition{
			Name:           "테스트 대회",
			ShowScoreboard: true,
		}

		err := storage.SetScoreboardVisibility(false)
		if err != nil {
			t.Errorf("Expected no error, got: %v", err)
		}

		if storage.competition.ShowScoreboard {
			t.Error("Scoreboard should be hidden")
		}
	})
}

func TestStorage_IsBlackoutPeriod(t *testing.T) {
	storage := &Storage{}

	t.Run("No competition", func(t *testing.T) {
		if storage.IsBlackoutPeriod() {
			t.Error("Should not be blackout period when no competition")
		}
	})

	now := time.Now()
	
	t.Run("Before blackout period", func(t *testing.T) {
		storage.competition = &models.Competition{
			BlackoutStartDate: now.Add(24 * time.Hour),
			EndDate:          now.Add(72 * time.Hour),
		}

		if storage.IsBlackoutPeriod() {
			t.Error("Should not be blackout period before blackout starts")
		}
	})

	t.Run("During blackout period", func(t *testing.T) {
		storage.competition = &models.Competition{
			BlackoutStartDate: now.Add(-24 * time.Hour),
			EndDate:          now.Add(24 * time.Hour),
		}

		if !storage.IsBlackoutPeriod() {
			t.Error("Should be blackout period during blackout")
		}
	})

	t.Run("After competition ends", func(t *testing.T) {
		storage.competition = &models.Competition{
			BlackoutStartDate: now.Add(-72 * time.Hour),
			EndDate:          now.Add(-24 * time.Hour),
		}

		if storage.IsBlackoutPeriod() {
			t.Error("Should not be blackout period after competition ends")
		}
	})
}

func TestStorage_UpdateCompetitionMethods(t *testing.T) {
	storage := &Storage{}

	t.Run("Update methods with no competition", func(t *testing.T) {
		err := storage.UpdateCompetitionName("새 이름")
		if err == nil {
			t.Error("Expected error when updating name with no competition")
		}

		err = storage.UpdateCompetitionStartDate(time.Now())
		if err == nil {
			t.Error("Expected error when updating start date with no competition")
		}

		err = storage.UpdateCompetitionEndDate(time.Now())
		if err == nil {
			t.Error("Expected error when updating end date with no competition")
		}
	})

	t.Run("Update methods with competition", func(t *testing.T) {
		storage.competition = &models.Competition{
			Name:      "기존 대회",
			StartDate: time.Date(2024, 1, 1, 0, 0, 0, 0, time.UTC),
			EndDate:   time.Date(2024, 1, 31, 0, 0, 0, 0, time.UTC),
		}

		newName := "새로운 대회명"
		err := storage.UpdateCompetitionName(newName)
		if err != nil {
			t.Errorf("Expected no error, got: %v", err)
		}
		if storage.competition.Name != newName {
			t.Errorf("Expected name '%s', got '%s'", newName, storage.competition.Name)
		}

		newStartDate := time.Date(2024, 2, 1, 0, 0, 0, 0, time.UTC)
		err = storage.UpdateCompetitionStartDate(newStartDate)
		if err != nil {
			t.Errorf("Expected no error, got: %v", err)
		}
		if !storage.competition.StartDate.Equal(newStartDate) {
			t.Errorf("Expected start date %v, got %v", newStartDate, storage.competition.StartDate)
		}

		newEndDate := time.Date(2024, 2, 28, 0, 0, 0, 0, time.UTC)
		err = storage.UpdateCompetitionEndDate(newEndDate)
		if err != nil {
			t.Errorf("Expected no error, got: %v", err)
		}
		if !storage.competition.EndDate.Equal(newEndDate) {
			t.Errorf("Expected end date %v, got %v", newEndDate, storage.competition.EndDate)
		}

		// 블랙아웃 기간이 자동으로 업데이트되었는지 확인
		expectedBlackout := newEndDate.AddDate(0, 0, -3)
		if !storage.competition.BlackoutStartDate.Equal(expectedBlackout) {
			t.Errorf("Expected blackout start %v, got %v", expectedBlackout, storage.competition.BlackoutStartDate)
		}
	})
}